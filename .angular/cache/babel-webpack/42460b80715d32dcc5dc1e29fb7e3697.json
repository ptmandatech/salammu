{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.RBush = factory());\n})(this, function () {\n  'use strict';\n\n  function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);\n  }\n\n  function quickselectStep(arr, k, left, right, compare) {\n    while (right > left) {\n      if (right - left > 600) {\n        var n = right - left + 1;\n        var m = k - left + 1;\n        var z = Math.log(n);\n        var s = 0.5 * Math.exp(2 * z / 3);\n        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n        quickselectStep(arr, k, newLeft, newRight, compare);\n      }\n\n      var t = arr[k];\n      var i = left;\n      var j = right;\n      swap(arr, left, k);\n\n      if (compare(arr[right], t) > 0) {\n        swap(arr, left, right);\n      }\n\n      while (i < j) {\n        swap(arr, i, j);\n        i++;\n        j--;\n\n        while (compare(arr[i], t) < 0) {\n          i++;\n        }\n\n        while (compare(arr[j], t) > 0) {\n          j--;\n        }\n      }\n\n      if (compare(arr[left], t) === 0) {\n        swap(arr, left, j);\n      } else {\n        j++;\n        swap(arr, j, right);\n      }\n\n      if (j <= k) {\n        left = j + 1;\n      }\n\n      if (k <= j) {\n        right = j - 1;\n      }\n    }\n  }\n\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n  function defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  var RBush = function RBush(maxEntries) {\n    if (maxEntries === void 0) maxEntries = 9; // max entries in a node is 9 by default; min node fill is 40% for best performance\n\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n  };\n\n  RBush.prototype.all = function all() {\n    return this._all(this.data, []);\n  };\n\n  RBush.prototype.search = function search(bbox) {\n    var node = this.data;\n    var result = [];\n\n    if (!intersects(bbox, node)) {\n      return result;\n    }\n\n    var toBBox = this.toBBox;\n    var nodesToSearch = [];\n\n    while (node) {\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        var childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) {\n            result.push(child);\n          } else if (contains(bbox, childBBox)) {\n            this._all(child, result);\n          } else {\n            nodesToSearch.push(child);\n          }\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  };\n\n  RBush.prototype.collides = function collides(bbox) {\n    var node = this.data;\n\n    if (!intersects(bbox, node)) {\n      return false;\n    }\n\n    var nodesToSearch = [];\n\n    while (node) {\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        var childBBox = node.leaf ? this.toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) {\n            return true;\n          }\n\n          nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return false;\n  };\n\n  RBush.prototype.load = function load(data) {\n    if (!(data && data.length)) {\n      return this;\n    }\n\n    if (data.length < this._minEntries) {\n      for (var i = 0; i < data.length; i++) {\n        this.insert(data[i]);\n      }\n\n      return this;\n    } // recursively build the tree with the given data from scratch using OMT algorithm\n\n\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        var tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      } // insert the small tree into the large tree at appropriate level\n\n\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n  };\n\n  RBush.prototype.insert = function insert(item) {\n    if (item) {\n      this._insert(item, this.data.height - 1);\n    }\n\n    return this;\n  };\n\n  RBush.prototype.clear = function clear() {\n    this.data = createNode([]);\n    return this;\n  };\n\n  RBush.prototype.remove = function remove(item, equalsFn) {\n    if (!item) {\n      return this;\n    }\n\n    var node = this.data;\n    var bbox = this.toBBox(item);\n    var path = [];\n    var indexes = [];\n    var i, parent, goingUp; // depth-first iterative tree traversal\n\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n\n      if (node.leaf) {\n        // check current node\n        var index = findItem(item, node.children, equalsFn);\n\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n\n          this._condense(path);\n\n          return this;\n        }\n      }\n\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else {\n        node = null;\n      } // nothing found\n\n    }\n\n    return this;\n  };\n\n  RBush.prototype.toBBox = function toBBox(item) {\n    return item;\n  };\n\n  RBush.prototype.compareMinX = function compareMinX(a, b) {\n    return a.minX - b.minX;\n  };\n\n  RBush.prototype.compareMinY = function compareMinY(a, b) {\n    return a.minY - b.minY;\n  };\n\n  RBush.prototype.toJSON = function toJSON() {\n    return this.data;\n  };\n\n  RBush.prototype.fromJSON = function fromJSON(data) {\n    this.data = data;\n    return this;\n  };\n\n  RBush.prototype._all = function _all(node, result) {\n    var nodesToSearch = [];\n\n    while (node) {\n      if (node.leaf) {\n        result.push.apply(result, node.children);\n      } else {\n        nodesToSearch.push.apply(nodesToSearch, node.children);\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  };\n\n  RBush.prototype._build = function _build(items, left, right, height) {\n    var N = right - left + 1;\n    var M = this._maxEntries;\n    var node;\n\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization\n\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height; // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M);\n    var N1 = N2 * Math.ceil(Math.sqrt(M));\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (var i = left; i <= right; i += N1) {\n      var right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n\n      for (var j = i; j <= right2; j += N2) {\n        var right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively\n\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n\n    calcBBox(node, this.toBBox);\n    return node;\n  };\n\n  RBush.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {\n    while (true) {\n      path.push(node);\n\n      if (node.leaf || path.length - 1 === level) {\n        break;\n      }\n\n      var minArea = Infinity;\n      var minEnlargement = Infinity;\n      var targetNode = void 0;\n\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        var area = bboxArea(child);\n        var enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement\n\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n\n      node = targetNode || node.children[0];\n    }\n\n    return node;\n  };\n\n  RBush.prototype._insert = function _insert(item, level, isNode) {\n    var bbox = isNode ? item : this.toBBox(item);\n    var insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too\n\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node\n\n\n    node.children.push(item);\n    extend(node, bbox); // split on node overflow; propagate upwards if necessary\n\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n\n        level--;\n      } else {\n        break;\n      }\n    } // adjust bboxes along the insertion path\n\n\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  }; // split overflowed node into two\n\n\n  RBush.prototype._split = function _split(insertPath, level) {\n    var node = insertPath[level];\n    var M = node.children.length;\n    var m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n\n    if (level) {\n      insertPath[level - 1].children.push(newNode);\n    } else {\n      this._splitRoot(node, newNode);\n    }\n  };\n\n  RBush.prototype._splitRoot = function _splitRoot(node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  };\n\n  RBush.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m, M) {\n    var index;\n    var minOverlap = Infinity;\n    var minArea = Infinity;\n\n    for (var i = m; i <= M - m; i++) {\n      var bbox1 = distBBox(node, 0, i, this.toBBox);\n      var bbox2 = distBBox(node, i, M, this.toBBox);\n      var overlap = intersectionArea(bbox1, bbox2);\n      var area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap\n\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n\n    return index || M - m;\n  }; // sorts node children by the best axis for split\n\n\n  RBush.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n    var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n\n    var xMargin = this._allDistMargin(node, m, M, compareMinX);\n\n    var yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n\n\n    if (xMargin < yMargin) {\n      node.children.sort(compareMinX);\n    }\n  }; // total margin of all possible split distributions where each node is at least m full\n\n\n  RBush.prototype._allDistMargin = function _allDistMargin(node, m, M, compare) {\n    node.children.sort(compare);\n    var toBBox = this.toBBox;\n    var leftBBox = distBBox(node, 0, m, toBBox);\n    var rightBBox = distBBox(node, M - m, M, toBBox);\n    var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n    for (var i = m; i < M - m; i++) {\n      var child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n\n    for (var i$1 = M - m - 1; i$1 >= m; i$1--) {\n      var child$1 = node.children[i$1];\n      extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);\n      margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n  };\n\n  RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  };\n\n  RBush.prototype._condense = function _condense(path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else {\n          this.clear();\n        }\n      } else {\n        calcBBox(path[i], this.toBBox);\n      }\n    }\n  };\n\n  function findItem(item, items, equalsFn) {\n    if (!equalsFn) {\n      return items.indexOf(item);\n    }\n\n    for (var i = 0; i < items.length; i++) {\n      if (equalsFn(item, items[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // calculate node's bbox from bboxes of its children\n\n\n  function calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n  } // min bounding rectangle of node children from k to p-1\n\n\n  function distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) {\n      destNode = createNode(null);\n    }\n\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k; i < p; i++) {\n      var child = node.children[i];\n      extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n  }\n\n  function extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n  }\n\n  function compareNodeMinX(a, b) {\n    return a.minX - b.minX;\n  }\n\n  function compareNodeMinY(a, b) {\n    return a.minY - b.minY;\n  }\n\n  function bboxArea(a) {\n    return (a.maxX - a.minX) * (a.maxY - a.minY);\n  }\n\n  function bboxMargin(a) {\n    return a.maxX - a.minX + (a.maxY - a.minY);\n  }\n\n  function enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n  }\n\n  function intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX);\n    var minY = Math.max(a.minY, b.minY);\n    var maxX = Math.min(a.maxX, b.maxX);\n    var maxY = Math.min(a.maxY, b.maxY);\n    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n  }\n\n  function contains(a, b) {\n    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n  }\n\n  function intersects(a, b) {\n    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n  }\n\n  function createNode(children) {\n    return {\n      children: children,\n      height: 1,\n      leaf: true,\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity\n    };\n  } // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n  // combines selection algorithm with binary divide & conquer approach\n\n\n  function multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right];\n\n    while (stack.length) {\n      right = stack.pop();\n      left = stack.pop();\n\n      if (right - left <= n) {\n        continue;\n      }\n\n      var mid = left + Math.ceil((right - left) / n / 2) * n;\n      quickselect(arr, mid, left, right, compare);\n      stack.push(left, mid, mid, right);\n    }\n  }\n\n  return RBush;\n});","map":null,"metadata":{},"sourceType":"script"}